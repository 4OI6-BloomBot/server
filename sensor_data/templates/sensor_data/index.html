{% extends "base.html" %}
{% load static %}

{% comment %}
    Template for displaying a table of measurements
    TODO: Can probably abstract the list part of the template and extend it for
          each list component in the project
{% endcomment %}

{% block content %}
    {% comment %} TODO: Don't really need to pass any measurement data to this anymore {% endcomment %}
    {% if measurement_list %} 
        <div style="width: 800px;"><canvas id="sensor_chart"></canvas></div>

        <table id="measurement_table" class="table">
            {% comment %} Table headers {% endcomment %}
            <thead>
                <tr>
                    <th scope="col">Device</th>
                    <th scope="col">Sensor Type</th>
                    <th scope="col">Value</th>
                    <th scope="col">Timestamp</th>
                </tr>
            </thead>
        </table>
    {% else %}
        <p>No measurements are available.</p>
    {% endif %}

    {% if sensor_list %}
        <button class="btn btn-primary" onclick="setSensorID(null)">All</button>
        {% for sensor in sensor_list %}
            <button class="btn btn-primary" onclick="setSensorID({{ sensor.pk }})">{{ sensor.name }}</button>
        {% endfor %}
    {% endif %}
{% endblock %}

{% block js %}
    {% comment %} TODO: This needs to be abstracted. There should be a class for the data management that the chart/table can grab from. {% endcomment %}

    {% comment %} ChartJS Import {% endcomment %}
    <script src="{% static './lib/chartjs/chart.min.js' %}"></script>

    <script>
        {% comment %}
          Declare the table
        {% endcomment %}
        table = new DataTable("#measurement_table", {
            columns: [
              { data: "device" },
              { data: "sensor" },
              { data: "value" },
              { data: "datetime" }
            ]
        });

        {% comment %} Globally accessible vars {% endcomment %}
        chart            = null;
        table_data       = [];
        device_data      = [];
        sensor_id        = null;
        last_received_id = null;
        
        {% comment %} 
          Fetch all the measurement data from the API
        {% endcomment %}
        function fetchMeasurements() {
            $.ajax({
                url:      "http://localhost:8000/api/measurements/", // TODO: Change to configurable route
                method:   'GET',
                dataType: 'json',
                data: {
                    sensor       : sensor_id,
                    last_received: last_received_id
                },

                success: function(d) {

                    // Skip updates if there is no new data
                    if (d.length > 0) {
                        parseDeviceData(d);

                        // Update the last received ID
                        last_received_id = d[d.length - 1].id;

                        updateChart();
                        updateTable(d);
                    }
                }
            });
        }

        {% comment %} 
          Find each of the unique devices from the data and separate the measurements
          into datasets for each device.
        {% endcomment %}
        function parseDeviceData(d) {
            devices = [...new Set(d.map(item => item.device))];

            // Separate the data by device ID for each dataset
            for (i = 0; i < devices.length; i++) {
                filtered_data = d.filter(item => item.device == devices[i]);
                table_data.push(...filtered_data);

                // Search the array for the object w/ the current device ID
                // dataset_index will be equal to the index of the object if it exists.
                // Undefined if not.
                dataset_index = device_data.findIndex(obj => { 
                    return obj.label === devices[i];
                });


                // Append the new data if the object already exists, otherwise create
                // the object.
                if (dataset_index != -1) appendMeasurementData(dataset_index, filtered_data);
                else                     createDatasetObj(devices[i],         filtered_data);
              }
        }


        {% comment %} 
          Creates a dataset out of the passed measurement data
        {% endcomment %}
        function createDatasetObj(label, data) {
            // Create a new object for the device data
            device_data.push(
              {
                label: label,
                data:  []
              }
            );

            appendMeasurementData(device_data.length - 1, data);
        }

        {% comment %} 
          Appends data to the given obj
        {% endcomment %}
        function appendMeasurementData(index, data) {
            
            // Iterate over each entry and parse data for chart format
            // TODO: This needs to be updated to add data in order of time. 
            //       Otherwise, the chart will go back over itself.
            for (j = 0; j < data.length; j++) {
                device_data[index].data.push(
                    {
                        x: data[j].datetime,
                        y: data[j].value
                    }
                );
            }
        }


        {% comment %} 
          Update the chart with the device data
        {% endcomment %}
        function createChart() {
            chart = new Chart(
                document.getElementById('sensor_chart'),
                {
                    type: 'line',            
                    data: {
                        datasets: device_data
                    }
                }
            );
        }


        {% comment %} 
          Update the chart datasets
        {% endcomment %}
        function updateChart() {
            chart.data.datasets = device_data;
            chart.update();
        }


        {% comment %} 
          Function to set the HTML parsing args
        {% endcomment %}
        function setSensorID(id) {
            sensor_id = id;

            // Reset data and last received id
            device_data      = [];
            table_data       = [];
            last_received_id = null;

            fetchMeasurements();
        }


        {% comment %} 
          Function to update the data in the table
          TODO: Shoudn't clear all data each time we add rows. 
        {% endcomment %}
        function updateTable() {
            table.clear();
            table.rows.add(table_data);
            table.draw();
        }

        {% comment %} 
          Setup chart and update data periodically (5 seconds)
        {% endcomment %}
        fetchMeasurements();
        createChart();

        const fetch = setInterval(fetchMeasurements, 5000);

    </script>
{% endblock %}